{"c++":"class Solution {\r\n    \r\n    \r\nclass cell {\r\npublic:\r\n    int row;\r\n    int col;\r\n    int height;\r\n    cell(int row, int col, int height) {\r\n        this->row=row;\r\n        this->col=col;\r\n        this->height=height;\r\n    }\r\n};\r\nclass mycomp {\r\npublic:\r\n    bool operator()(const cell& a, const cell&b) const {\r\n        return a.height>b.height;\r\n    }    \r\n};\r\n    \r\npublic:\r\n    int trapRainWater(vector<vector<int>>& heightMap) {\r\n        if(heightMap.empty() || heightMap[0].empty()) return 0;\r\n        priority_queue<cell, vector<cell>, mycomp> queue;        \r\n\r\n        int m=heightMap.size(), n=heightMap[0].size();\r\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\r\n\r\n        for(int i=0; i<m; ++i) {\r\n            visited[i][0]=1;\r\n            visited[i][n-1]=1;\r\n            queue.push(cell(i,0,heightMap[i][0]));\r\n            queue.push(cell(i,n-1,heightMap[i][n-1]));\r\n        }\r\n        for(int i=0; i<n; ++i) {\r\n            visited[0][i]=1;\r\n            visited[m-1][i]=1;\r\n            queue.push(cell(0,i,heightMap[0][i]));\r\n            queue.push(cell(m-1,i,heightMap[m-1][i]));\r\n        }        \r\n        \r\n        int res=0;\r\n        vector<pair<int, int>> dirs={{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n        \r\n        while(!queue.empty()) {\r\n            cell cur=queue.top();\r\n            queue.pop();\r\n            for(auto dir: dirs) {\r\n                int row=cur.row+dir.first;\r\n                int col=cur.col+dir.second;\r\n                if(row>-1 && row<m && col>-1 && col<n && !visited[row][col]) {\r\n                    visited[row][col]=1;\r\n                    res+=max(0, cur.height-heightMap[row][col]);    \r\n                    queue.push(cell(row, col, max(cur.height, heightMap[row][col])));\r\n                }\r\n            }\r\n        }\r\n        \r\n        \r\n        \r\n        \r\n        return res;\r\n    }\r\n};"}