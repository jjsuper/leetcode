{"c++":"class LFUCache {\r\n    private:\r\n    int cap;\r\n    int size;\r\n    int minfreq;\r\n    \r\n    unordered_map<int, pair<int, int>> m; //key  {value,freq}\r\n    unordered_map<int, list<int>> fm; //freq list<key>\r\n    unordered_map<int, list<int>::iterator> mIter; //key iterator\r\npublic:\r\n\r\n    LFUCache(int capacity) {\r\n        cap=capacity;\r\n        size=0;\r\n       // minfreq=1;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if(!m.count(key)) return -1;\r\n        \r\n        fm[m[key].second].erase(mIter[key]);\r\n        m[key].second++;\r\n        fm[m[key].second].push_back(key);\r\n        mIter[key]=--fm[m[key].second].end();\r\n        \r\n        if(fm[minfreq].size()==0) minfreq++;\r\n        \r\n        return m[key].first;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if(cap<=0) return;\r\n        \r\n        int storedvalue=get(key);\r\n        if(storedvalue!=-1) {\r\n            m[key].first=value;\r\n            return;\r\n        }\r\n        \r\n        if(size>=cap) {\r\n            m.erase(fm[minfreq].front());\r\n            mIter.erase(fm[minfreq].front());\r\n            fm[minfreq].pop_front();\r\n            size--;\r\n        }\r\n        \r\n        m[key]={value, 1};\r\n        minfreq=1;\r\n        fm[1].push_back(key);\r\n        mIter[key]=--fm[1].end();\r\n        size++;\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Your LFUCache object will be instantiated and called as such:\r\n * LFUCache obj = new LFUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n /*\r\nclass LFUCache {\r\n    int cap;\r\n    int size;\r\n    int minFreq;\r\n    unordered_map<int, pair<int, int>> m; //key to {value,freq};\r\n    unordered_map<int, list<int>::iterator> mIter; //key to list iterator;\r\n    unordered_map<int, list<int>>  fm;  //freq to key list;\r\npublic:\r\n    LFUCache(int capacity) {\r\n        cap=capacity;\r\n        size=0;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if(m.count(key)==0) return -1;\r\n        \r\n        fm[m[key].second].erase(mIter[key]);\r\n        m[key].second++;\r\n        fm[m[key].second].push_back(key);\r\n        mIter[key]=--fm[m[key].second].end();\r\n        \r\n        if(fm[minFreq].size()==0 ) \r\n              minFreq++;\r\n        \r\n        return m[key].first;\r\n    }\r\n    \r\n   void put(int key, int value) {\r\n        if(cap<=0) return;\r\n        \r\n        int storedValue=get(key);\r\n        if(storedValue!=-1)\r\n        {\r\n            m[key].first=value;\r\n            return;\r\n        }\r\n        \r\n        if(size>=cap )\r\n        {\r\n            m.erase( fm[minFreq].front() );\r\n            mIter.erase( fm[minFreq].front() );\r\n            fm[minFreq].pop_front();\r\n            size--;\r\n        }\r\n        \r\n        m[key]={value, 1};\r\n        fm[1].push_back(key);\r\n        mIter[key]=--fm[1].end();\r\n        minFreq=1;\r\n        size++;\r\n    }\r\n};*/"}