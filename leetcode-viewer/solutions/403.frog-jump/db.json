{"c++":"class Solution {\r\npublic:\r\n   /* bool canCross(vector<int>& stones) {\r\n        \r\n        int k=1;\r\n        for(int i=2; i<stones.size(); ++i) {\r\n            int gap=stones[i]-stones[i-1];\r\n            if(gap<k-1 || gap>k+1) return false;\r\n            k=gap;\r\n        }\r\n        return true;\r\n          //[0,1,3,5,6,8,12,17]\r\n        \r\n        \r\n        return canCross(stones, 0, 0);\r\n        \r\n        \r\n    }*/\r\n/*\r\nunordered_map<int, bool> dp;\r\n\r\nbool canCross(vector<int>& stones, int pos = 0, int k = 0) {\r\n    int key = pos | k << 11;\r\n\r\n    if (dp.count(key) > 0)\r\n        return dp[key];\r\n\r\n    for (int i = pos + 1; i < stones.size(); i++) {\r\n        int gap = stones[i] - stones[pos];\r\n        if (gap < k - 1)\r\n            continue;\r\n        if (gap > k + 1)\r\n            return dp[key] = false;\r\n        if (canCross(stones, i, gap))\r\n            return dp[key] = true;\r\n    }\r\n\r\n    return dp[key] = (pos == stones.size() - 1);\r\n    }*/\r\n    \r\n    bool canCross(vector<int>& stones) {\r\n        unordered_map<int, unordered_set<int>> hash;\r\n        \r\n        for(int i=0; i<stones.size(); ++i) {\r\n            hash.insert(make_pair(stones[i], unordered_set<int>()));\r\n        }\r\n        hash[stones[0]].insert(0);\r\n        \r\n        for(int i=0; i<stones.size(); ++i) {\r\n            for(auto k: hash[stones[i]]) {\r\n                for(int step=k-1; step<=k+1; ++step) {\r\n                    if(step>0 && hash.count(step+stones[i])>0){\r\n                        hash[step+stones[i]].insert(step);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return hash[stones[stones.size()-1]].size()>0;\r\n    }\r\n    \r\n};"}