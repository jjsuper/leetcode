{"c++":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * class NestedInteger {\r\n *   public:\r\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\r\n *     bool isInteger() const;\r\n *\r\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\r\n *     // The result is undefined if this NestedInteger holds a nested list\r\n *     int getInteger() const;\r\n *\r\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\r\n *     // The result is undefined if this NestedInteger holds a single integer\r\n *     const vector<NestedInteger> &getList() const;\r\n * };\r\n */\r\nclass NestedIterator {\r\npublic:\r\n    NestedIterator(vector<NestedInteger> &nestedList) {\r\n        begins.push(nestedList.begin());\r\n        ends.push(nestedList.end());\r\n    }\r\n\r\n    int next() {\r\n        hasNext();\r\n        return (begins.top()++)->getInteger();\r\n    }\r\n\r\n    bool hasNext() {\r\n         while (begins.size()) {\r\n            if (begins.top() == ends.top()) {\r\n                begins.pop();\r\n                ends.pop();\r\n            } else {\r\n                auto x = begins.top();\r\n                if (x->isInteger())\r\n                    return true;\r\n                begins.top()++;\r\n                begins.push(x->getList().begin());\r\n                ends.push(x->getList().end());\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\nprivate:\r\n    stack<vector<NestedInteger>::iterator> begins, ends;\r\n};\r\n\r\n/**\r\n * Your NestedIterator object will be instantiated and called as such:\r\n * NestedIterator i(nestedList);\r\n * while (i.hasNext()) cout << i.next();\r\n */"}