{"c++":"class LRUCache {\r\npublic:\r\n    LRUCache(int capacity) : capacity_(capacity) { }\r\n    \r\n    int get(int key) {\r\n        auto it=cache.find(key);\r\n        if(it==cache.end()) return -1;\r\n        touch(it);\r\n        return it->second.first;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        auto it=cache.find(key);\r\n        if(it!=cache.end()) touch(it);\r\n        else {\r\n            if(cache.size()==capacity_) {\r\n                cache.erase(used.back());\r\n                used.pop_back();\r\n            }\r\n            used.push_front(key);\r\n        }\r\n        cache[key]={value, used.begin()};\r\n    }\r\nprivate:\r\n    typedef list<int> LI;\r\n    typedef pair<int, LI::iterator> PII;\r\n    typedef unordered_map<int, PII> HIPII;\r\n    \r\n    void touch(HIPII::iterator it) {\r\n        int key=it->first;\r\n        used.erase(it->second.second);\r\n        used.push_front(key);\r\n        it->second.second=used.begin();\r\n    }\r\n\r\n    HIPII cache;\r\n    LI used;\r\n    int capacity_;\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */"}