{"c++":"class Solution {\r\npublic:\r\n    int maxProfit(int k, vector<int>& prices) {\r\n        // f[k, ii] represents the max profit up until prices[ii] (Note: NOT ending with prices[ii]) using at most k transactions. \r\n        // f[k, ii] = max(f[k, ii-1], prices[ii] - prices[jj] + f[k-1, jj]) { jj in range of [0, ii-1] }\r\n        //          = max(f[k, ii-1], prices[ii] + max(f[k-1, jj] - prices[jj]))\r\n        // f[0, ii] = 0; 0 times transation makes 0 profit\r\n        // f[k, 0] = 0; if there is only one price data point you can't make any money no matter how many times you can trade\r\n        if(prices.size()<2) return 0;\r\n        \r\n        \r\n        //if k >= n/2, then you can make maximum number of transactions.\r\n\tif (k >=  prices.size()/2) {\r\n\t\tint maxPro = 0;\r\n\t\tfor (int i = 1; i < prices.size(); i++) {\r\n\t\t\tif (prices[i] > prices[i-1])\r\n\t\t\t\tmaxPro += prices[i] - prices[i-1];\r\n\t\t}\r\n\t\treturn maxPro;\r\n\t}\r\n        \r\n        vector<vector<int>> dp(k+1, vector<int>(prices.size(), 0));\r\n        \r\n        for(int i=1; i<=k; ++i) {\r\n            int tmpMax=dp[i-1][0]-prices[0];\r\n            for(int j=1; j<prices.size(); ++j) {\r\n                dp[i][j]=max(dp[i][j-1], prices[j]+tmpMax);\r\n                tmpMax=max(tmpMax, dp[i-1][j]-prices[j]);\r\n            }\r\n        }\r\n        \r\n        return dp[k][prices.size()-1];\r\n    }\r\n};"}