{"c++":"class Solution {\r\npublic:\r\n    int strongPasswordChecker(string s) {\r\n        int deleteTarget=max(0, (int)s.size()-20), addTarget=max(0, 6-(int)s.size());\r\n        int toAdd=0, toDelete=0, toReplace=0, needUpper=1, needLower=1, needDigit=1;\r\n        \r\n        ///////////////////////////////////\r\n        // For cases of s.length() <= 20 //\r\n        ///////////////////////////////////\r\n        for(int l=0, r=0; r<s.size(); ++r) {\r\n            if(isupper(s[r])) needUpper=0;\r\n            if(islower(s[r])) needLower=0;\r\n            if(isdigit(s[r])) needDigit=0;\r\n            \r\n             // if it's a three-letter window\r\n             // found a three-repeating substr\r\n             // insert letter to break repetition if possible\r\n             // replace current word to avoid three repeating chars\r\n             // keep the window with no more than 3 letters\r\n            if(r-l==2) {\r\n                if(s[r]==s[r-1]&&s[r-1]==s[l]) {\r\n                    if(toAdd < addTarget) {\r\n                        toAdd++;\r\n                        l=r;\r\n                    }\r\n                    else {\r\n                        toReplace++;\r\n                        l=r+1;\r\n                    }\r\n                }\r\n                else {\r\n                    l++;\r\n                }\r\n            }\r\n            \r\n        }\r\n        if(s.size()<=20) return max(addTarget+toReplace, needUpper+needLower+needDigit);\r\n        \r\n       \r\n        //////////////////////////////////\r\n        // For cases of s.length() > 20 //\r\n        //////////////////////////////////\r\n        toReplace=0;\r\n         // reset toReplace\r\n         // to record repetitions with (length % 3) == 0, 1 or 2\r\n         // record all repetion frequencies\r\n         // we only care about repetions with length >= 3\r\n        vector<unordered_map<int, int>> hash(3);\r\n        for(int l=0, r=0, len; r<=s.size(); ++r) {\r\n            if(r==s.size() || s[l]!=s[r]) {\r\n                if((len=r-l) > 2) hash[len%3][len]++;\r\n                l=r;\r\n            }\r\n        }\r\n   \r\n         /*\r\n            Use deletions to minimize replacements, following below orders:\r\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\r\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\r\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \r\n            letters) decreases repalcements by 1\r\n        */\r\n        \r\n    // dec is the number of repetitions we'll delete from\r\n    // update number of repetitions left\r\n    // after letters deleted, it fits in the group where (length % 3) == 2\r\n    // record number of replacements needed\r\n    // note if len is the length of repetition, we need (len / 3) number of replacements\r\n        \r\n        \r\n        for(int i=0; i<3; ++i) {\r\n            for(auto it : hash[i]) {\r\n                if(i<2) {\r\n                    int numLetter=i+1; \r\n                    int dec=min(it.second, (deleteTarget- toDelete)/numLetter);\r\n                    toDelete += dec*numLetter;\r\n                    it.second -= dec;\r\n                    \r\n                    if(it.first-numLetter>2) {\r\n                        hash[2][it.first-numLetter] += dec;\r\n                    }\r\n                }\r\n                \r\n                toReplace+= (it.second)*(it.first/3);\r\n            }\r\n        }\r\n        \r\n        int dec=(deleteTarget-toDelete)/3;\r\n        toReplace-=dec;\r\n        toDelete-=dec*3;\r\n          \r\n         // try to delete multiple of three letters as many as possible\r\n        return deleteTarget+max(toReplace, needUpper+needLower+needDigit);\r\n        \r\n    }\r\n};"}