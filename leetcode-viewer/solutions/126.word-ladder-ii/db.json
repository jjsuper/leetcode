{"c++":"class Solution {\r\npublic:\r\nvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\r\n    unordered_set<string> dict(wordList.begin(), wordList.end());\r\n    vector<vector<string>> res;         \r\n    unordered_map<string, vector<string>> nodeNeighbors;    // Neighbors for every node\r\n    unordered_map<string, int> distance;    // Distance of every node from the start node\r\n    vector<string> solution;\r\n  \r\n  \r\n    // BFS: Trace every node's distance from the start node (level by level).\r\n    queue<string> q;\r\n    q.push(beginWord);\r\n    distance[beginWord]=0;\r\n    bool foundEnd=false;\r\n    \r\n    while(!q.empty()&&!foundEnd) {\r\n        int n=q.size();\r\n        unordered_set<string> used;\r\n        for(int i=0; i<n; ++i) {\r\n            string cur=q.front();\r\n            q.pop();\r\n            int curDist=distance[cur];\r\n            vector<string> neighbors = getNeighbors(cur, dict);\r\n            //nodeNeighbors[cur]=neighbors;\r\n            for(string next: neighbors) {\r\n                used.insert(next);\r\n                if (!distance.count(next)) {// Check if visited\r\n                    nodeNeighbors[cur].push_back(next); \r\n                    distance[next]=curDist+1;\r\n                    if (endWord==next)// Found the shortest path\r\n                        foundEnd=true;\r\n                    else\r\n                        q.push(next);\r\n                }\r\n                else {\r\n                    if(distance[next]==curDist+1)\r\n                        nodeNeighbors[cur].push_back(next); \r\n                }\r\n            }\r\n        }\r\n        \r\n        for(string u: used) {\r\n            dict.erase(u);\r\n        }\r\n    }\r\n    \r\n    dfs(beginWord, endWord, nodeNeighbors, distance, solution, res);   \r\n    return res;\r\n}\r\n\r\n\r\n\r\n\r\n// Find all next level nodes.    \r\nvector<string> getNeighbors(string node, unordered_set<string>& dict) {\r\n    vector<string> res;\r\n    for(int i=0; i<node.size(); ++i) {\r\n        for(char c='a'; c<='z'; ++c) {\r\n            if(c==node[i]) continue;\r\n            string nnode=node;\r\n            nnode[i]=c;\r\n            if(dict.count(nnode)) {\r\n                res.push_back(nnode);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n// DFS: output all paths with the shortest distance.\r\nvoid dfs(string cur, string end, unordered_map<string, vector<string>>& nodeNeighbors, unordered_map<string, int>& distance, vector<string> &solution, vector<vector<string>>& res) {\r\n    solution.push_back(cur);\r\n    if(cur==end) {\r\n        res.push_back(solution);\r\n    }\r\n    else {\r\n        for(string next: nodeNeighbors[cur]) {\r\n        if(distance[next]==distance[cur]+1) \r\n            dfs(next, end, nodeNeighbors, distance, solution, res);\r\n        }\r\n    }\r\n    solution.pop_back();\r\n}\r\n\r\n};"}